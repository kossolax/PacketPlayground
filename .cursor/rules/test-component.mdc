---
description: 
globs: *.test.tsx,*.test.ts,*.test.js,*.test.jsx
alwaysApply: false
---
= Test Writing Principles =

**Always test**: renders, props, interactions, edge cases, error states
**Write failing tests first** - fix component bugs if needed
**Run after writing**: `cd frontend ; nvm use --lts && npm test file.test.tsx`

= Test Structure =
```ts
describe('Component', () => {
  const renderComponent = (props = {}) => {
    const defaultProps = { onValueChange: vi.fn() };
    // render logic
  };

  describe('Rendering', () => { /* basic + props + children */ });
  describe('Interactions', () => { /* events + callbacks */ });
  describe('Edge Cases', () => { /* errors + destructive actions */ });
});
```

= Element Selection (Priority Order) =
1. **Role + Name**: `screen.getByRole('button', { name: /create/i })`
2. **LabelText**: `screen.getByLabelText('Username')`
3. **Scoped queries**: `within(dialog).getByText('Content')`
4. **Fallback**: `querySelector('form')` for unsemantic elements

**Never use `data-testid`**

= Dialog/Modal Testing =
```ts
// Standard pattern
const trigger = screen.getByRole('button', { name: 'Open' });
await userEvent.click(trigger);
const dialog = screen.getByRole('dialog');

const input = within(dialog).getByRole('textbox');
await userEvent.type(input, 'value');

fireEvent.submit(dialog.querySelector('form'));
await waitFor(() => expect(mockApi.create).toHaveBeenCalled());
```

= ShadCN/NextJS Specifics =
- **Multiple text instances**: Use `within()` scoping or `getAllByText()` with length checks
- **Portals**: Always query dialogs first, then scope within
- **Debug DOM**: `screen.debug()` when targeting fails
- **Checkboxes**: `fireEvent.click()` more reliable than `userEvent.click()`
- **Forms**: Submit via `fireEvent.submit(form)` or click submit button

= Interaction Patterns =
- **User events**: `userEvent` for typing, clicking buttons
- **Fire events**: `fireEvent` for form submission, checkbox toggling
- **Async operations**: Wrap in `waitFor()` with specific assertions
- **Toast testing**: Test function calls directly, not UI rendering

= Common Patterns =
```ts
// Mocking
const mockHook = {
  query: { data: [], isLoading: false },
  create: vi.fn().mockResolvedValue({ id: 'new' }),
  update: vi.fn().mockResolvedValue(true)
};

// Checkbox groups
const group = screen.getByRole('group');
const checkbox = within(group).getByLabelText('Option');
fireEvent.click(checkbox);

// Select/Deselect All
await userEvent.click(screen.getByText('Select All'));
screen.getAllByRole('checkbox').forEach(cb => expect(cb).toBeChecked());
```

= Test Categories =
**Rendering**: Component mounts, props apply, children display
**Behavior**: Callbacks fire, state changes, API calls
**Validation**: Required props enforced, error handling
**Edge Cases**: Empty states, loading states, destructive confirmations

✅ **Good**: Test real components, use semantic selectors, test behavior
❌ **Avoid**: Unnecessary mocking, implementation details, data-testid

```ts
// ✅ Good - Test with real ShadCN components
it('should update form when input changes', async () => {
  render(<MyForm />);
  const input = screen.getByRole('textbox', { name: 'Username' });
  await userEvent.type(input, 'newuser');
  expect(input).toHaveValue('newuser');
});

// ❌ Avoid - Unnecessary mocking
vi.mock('@/components/ui/input', () => ({ Input: vi.fn() }));